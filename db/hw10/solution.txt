1.1

start transaction isolation level read committed

-- Виды аномалий по ослабеванию минимального требуемого уровня
-- изоляции: КЗ, ФЗ, НЧ, ГЧ.
-- КЗ встречается при всех кроме S. ГЧ встречается только при RU
-- КЗ невозможно так как у нас запросы только на чтение
-- ФЗ невозможно так как прочитать можем только 1 раз
-- НЧ невозможно так как прочитать можем только 1 раз
-- ГЧ возможно: в отменненной транзакции место купили и оно должно
-- быть свободным, но мы посчитаем его купленым
-- Следовательно чтобы исключить все аномалии, достаточно уровня RC


1.2

start transaction isolation level snapshot

-- Так как нам нужно делать запись, то уровень RU нам не подходит
-- КЗ невозможно так как обновляем только одно место, а для КЗ
-- необходимо обновление разных записей
-- ФЗ возможно так как после того как убедимся что место не
-- забронированно, то может сначала случиться другая бронь
-- с теми же параметрами и потом мы снова еще раз сделаем нашу бронь
-- на это место
-- Следовательно чтобы исключить все аномалии, достаточно уровня RC

1.3

start transaction isolation level read committed

-- Так как нам нужно делать запись, то уровень RU нам не подходит
-- КЗ невозможно так как обновляем только одно место, а для КЗ
-- необходимо обновление разных записей
-- ФЗ невозможно так как читаем только 1 раз
-- НЧ невозможно так как читаем только 1 раз
-- Следовательно чтобы исключить все аномалии, достаточно уровня RC

1.4

start transaction isolation level snapshot

-- Так как нам нужно делать запись, то уровень RU нам не подходит
-- КЗ невозможно так как пишем только в одно место, а для КЗ
-- необходимо обновление разных записей
-- ФЗ возможно так как после того как убедимся что место не
-- забронированно, то может сначала случиться другая бронь
-- с теми же параметрами и потом мы снова еще раз сделаем нашу бронь
-- на это место
-- Следовательно чтобы исключить все аномалии, достаточно уровня SN

1.5

start transaction isolation level read committed

-- Так как нам нужно делать запись, то уровень RU нам не подходит
-- КЗ невозможно так как обновляем только одно место, а для КЗ
-- необходимо обновление разных записей
-- ФЗ невозможно так как читаем только 1 раз
-- НЧ невозможно так как читаем только 1 раз
-- Следовательно чтобы исключить все аномалии, достаточно уровня RC

1.6

start transaction isolation level read uncommitted

-- КЗ невозможно так как у нас запросы только на чтение
-- ФЗ невозможно так как читаем только 1 раз
-- НЧ невозможно так как читаем только 1 раз
-- ГЧ возможно, но так как мы собираем статистику, то
-- погрешность неизбежна (обсуждали на лекции) и чтобы не тормозить
-- исполнение не будем попусту повышать уровень изоляции
-- Следовательно чтобы исключить все аномалии, достаточно уровня RU

1.7

start transaction isolation level read uncommitted

-- Так как нам нужно делать запись, то уровень RU нам не подходит
-- КЗ невозможно так как у нас запросы только на чтение
-- ФЗ невозможно так как читаем только 1 раз
-- НЧ невозможно так как читаем только 1 раз
-- ГЧ возможно, но так как мы собираем статистику, то
-- погрешность неизбежна (обсуждали на лекции) и чтобы не тормозить
-- исполнение не будем попусту повышать уровень изоляции
-- Следовательно чтобы исключить все аномалии, достаточно уровня RU

1.8

start transaction isolation level serializable

-- Так как нам нужно делать запись, то уровень RU нам не подходит
-- КЗ возможно так как у нас происходит одновременное 
-- обновление разных записей, основанное на одних и тех же данных
-- Следовательно чтобы исключить все аномалии, достаточно уровня S

2.0

Пользователь будет взаимодействовать с нашей БД, путем некоторого 
интерфейса, детали реализации которого нам не очень важны.
Бронирование места пользователем будет состоять из трех основных
этапов. 1) Показ информации о свободных местах по выбранному 
пользователем рейсу. 2) Выбор пользователем нужного ему числа
мест. 3) Внесение информации о бронировании в базу данных


2.1

start transaction isolation level read committed;
select freeSeats(:flightId);
commit;

2.2

После того как пользователь выберет рейс он сможет выбирать одно или
несколько мест. Зарезервированные места не будут клибкабельными и 
тыкабельными. После того как пользователь подтвердит свой выбор 
будет проведена попытка зарезервировать все места. Если за то время
пока пользователь резервировал места какое-то из мест кто-то 
другой зарезервирует, то пользователя уведомят о невозможности
бронирования этого набора мест и вернут на стадию выбора места 
(с сохранением еще свободных мест из его предыдущего выбора)

2.3

start transaction isolation level snapshot;
select Reserve(UserId, Pass, FlightId, SeatNo);
commit;

start transaction isolation level read committed;
select ExtendReservation(UserId, Pass, FlightId, SeatNo);
commit;

start transaction isolation level snapshot;
select BuyFree(FlightId, SeatNo);
commit;

start transaction isolation level read committed;
select BuyReserved(UserId, Pass, FlightId, SeatNo)
commit;